From 9daf4161454f9ad3131e6830f9e52579adc81042 Mon Sep 17 00:00:00 2001
From: Daizhiyuan <daizhiyuan@phytium.com.cn>
Date: Mon, 16 Oct 2023 14:38:19 +0800
Subject: [PATCH] hw: pci: add emulate device XPU for addition and
 multiplication

Signed-off-by: Daizhiyuan <daizhiyuan@phytium.com.cn>
---
 hw/misc/Kconfig       |   5 ++
 hw/misc/meson.build   |   1 +
 hw/misc/xpu_pci_dev.c | 172 ++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 178 insertions(+)
 create mode 100644 hw/misc/xpu_pci_dev.c

diff --git a/hw/misc/Kconfig b/hw/misc/Kconfig
index e4c2149175..3ae71fef40 100644
--- a/hw/misc/Kconfig
+++ b/hw/misc/Kconfig
@@ -30,6 +30,11 @@ config EDU
     default y if TEST_DEVICES
     depends on PCI && MSI_NONBROKEN
 
+config XPUDEV
+    bool
+	default y if TEST_DEVICES
+	depends on PCI && MSI_NONBROKEN
+
 config PCA9552
     bool
     depends on I2C
diff --git a/hw/misc/meson.build b/hw/misc/meson.build
index 05877f61cc..69b2c688c7 100644
--- a/hw/misc/meson.build
+++ b/hw/misc/meson.build
@@ -1,5 +1,6 @@
 system_ss.add(when: 'CONFIG_APPLESMC', if_true: files('applesmc.c'))
 system_ss.add(when: 'CONFIG_EDU', if_true: files('edu.c'))
+system_ss.add(when: 'CONFIG_XPUDEV', if_true: files('xpu_pci_dev.c'))
 system_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('vmcoreinfo.c'))
 system_ss.add(when: 'CONFIG_ISA_DEBUG', if_true: files('debugexit.c'))
 system_ss.add(when: 'CONFIG_ISA_TESTDEV', if_true: files('pc-testdev.c'))
diff --git a/hw/misc/xpu_pci_dev.c b/hw/misc/xpu_pci_dev.c
new file mode 100644
index 0000000000..76c7755dc6
--- /dev/null
+++ b/hw/misc/xpu_pci_dev.c
@@ -0,0 +1,172 @@
+#include "qemu/osdep.h"
+#include "qemu/units.h"
+#include "hw/pci/pci.h"
+#include "hw/hw.h"
+#include "hw/pci/msi.h"
+#include "qemu/timer.h"
+#include "qom/object.h"
+#include "qemu/main-loop.h"
+#include "qemu/module.h"
+#include "qapi/visitor.h"
+
+#define TYPE_PCI_XPU_DEVICE "xpudev"
+
+typedef struct XpudevState XpudevState;
+
+DECLARE_INSTANCE_CHECKER(XpudevState, XPUDEV, TYPE_PCI_XPU_DEVICE)
+
+struct XpudevState {
+	PCIDevice pdev;
+	MemoryRegion mmio;
+	uint32_t op1;
+	uint32_t op2;
+	uint32_t opcode;
+	uint32_t result;
+	uint32_t error_code;
+};
+
+static uint64_t xpudev_mmio_read(void *opaque, hwaddr addr, unsigned size)
+{
+	XpudevState *xpudev = opaque;
+	uint64_t val = ~0ULL;
+
+	if (addr < 0x80 && size != 4) {
+		return val;
+	}
+
+	switch (addr) {
+		case 0x00:
+			val = 0x12345678;
+			break;
+
+		case 0x10:
+			val = xpudev->op1;
+			break;
+
+		case 0x14:
+			val = xpudev->op2;
+			break;
+
+		case 0x18:
+			val = xpudev->opcode;
+			break;
+
+		case 0x30:
+			if(xpudev->opcode == 0x1) {
+				xpudev->result = xpudev->op1 + xpudev->op2;
+				xpudev->error_code = 0x0;
+			} else if(xpudev->opcode == 0x2) {
+				xpudev->result = xpudev->op1 * xpudev->op2;
+				xpudev->error_code = 0x0;
+			} else {
+				xpudev->result = 0xff;
+				xpudev->error_code = 0x1;
+			}
+
+			val = xpudev->result;
+			break;
+	}
+
+	return val;
+}
+
+static void xpudev_mmio_write(void *opaque, hwaddr addr, uint64_t val,
+		unsigned size)
+{
+	XpudevState *xpudev = opaque;
+
+	if (addr < 0x80 && size != 4) {
+		return;
+	}
+
+	switch (addr) {
+		case 0x10:
+			xpudev->op1 = val;
+			break;
+
+		case 0x14:
+			xpudev->op2 = val;
+			break;
+
+		case 0x18:
+			xpudev->opcode = val;
+			break;
+	}
+}
+
+static const MemoryRegionOps xpudev_mmio_ops = {
+	.read = xpudev_mmio_read,
+	.write = xpudev_mmio_write,
+	.endianness = DEVICE_NATIVE_ENDIAN,
+	.valid = {
+		.min_access_size = 4,
+		.max_access_size = 8,
+	},
+	.impl = {
+		.min_access_size = 4,
+		.max_access_size = 8,
+	},
+};
+
+static void pci_xpudev_realize(PCIDevice *pdev, Error **errp)
+{
+	XpudevState *xpudev = XPUDEV(pdev);
+	uint8_t *pci_conf = pdev->config;
+
+	pci_config_set_interrupt_pin(pci_conf, 1);
+
+	xpudev->op1 = 0x1;
+	xpudev->op2 = 0x2;
+	xpudev->opcode = 0x1;
+	xpudev->result = 0x3;
+	xpudev->error_code = 0x00;
+
+	memory_region_init_io(&xpudev->mmio, OBJECT(xpudev), &xpudev_mmio_ops, xpudev, "xpudev-mmio", 1 * MiB);
+	pci_register_bar(pdev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &xpudev->mmio);
+}
+
+static void pci_xpudev_uninit(PCIDevice *pdev)
+{
+	return;
+}
+
+static void xpudev_instance_init(Object *obj)
+{
+	return ;
+}
+
+static void xpudev_class_init(ObjectClass *class, void *data)
+{
+	DeviceClass *dc = DEVICE_CLASS(class);
+	PCIDeviceClass *k = PCI_DEVICE_CLASS(class);
+
+	k->realize = pci_xpudev_realize;
+	k->exit = pci_xpudev_uninit;
+	k->vendor_id = 0x1db7;
+	k->device_id = 0xdc3d;
+	k->revision = 0x01;
+	k->class_id = PCI_CLASS_OTHERS;
+
+	set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+}
+
+static void pci_xpu_device_register_types(void)
+{
+	static InterfaceInfo interfaces[] = {
+		{ INTERFACE_CONVENTIONAL_PCI_DEVICE },
+		{ },
+	};
+
+	static const TypeInfo xpu_pci_device_info = {
+		.name          = TYPE_PCI_XPU_DEVICE,
+		.parent        = TYPE_PCI_DEVICE,
+		.instance_size = sizeof(XpudevState),
+		.instance_init = xpudev_instance_init,
+		.class_init    = xpudev_class_init,
+		.interfaces = interfaces,
+	};
+
+	type_register_static(&xpu_pci_device_info);
+}
+
+type_init(pci_xpu_device_register_types)
-- 
2.17.1

